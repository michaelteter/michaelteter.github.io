<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lives</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #EEE;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none; /* Let clicks pass through to canvas if we add interaction later */
        }
    </style>
</head>
<body>
    <!-- <div id="controls">
        Stacked Game of Life<br>
    </div> -->
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Drawing Styles
        const DRAW_STYLES = {
            SOLID: 'SOLID',
            TL_DIAG_LINES: 'TL_DIAG_LINES', // Top-Left to Bottom-Right
            BL_DIAG_LINES: 'BL_DIAG_LINES', // Bottom-Left to Top-Right
            H_LINES: 'H_LINES',             // Horizontal
            V_LINES: 'V_LINES',             // Vertical
            CIRCLES: 'CIRCLES',             // Concentric circle outlines, similar to the lines regarding stroke width and gaps between circles
            SOLID_CIRCLE: 'SOLID_CIRCLE'    // Solid circle
        };


        // Configuration
        const CONFIG = {
            // Blend mode for compositing layers:
            //   'multiply'    - Use with LIGHT backgrounds and DARK layer colors (subtractive, like ink on paper)
            //   'lighter'     - Use with DARK backgrounds and LIGHT layer colors (additive, like light beams)
            //   'source-over' - Normal blending, no special mixing between layers
            blendMode: 'lighter',
            cellSizePercent: 0.1,     // Size of each cell as % of min dimension (0.1 = 10%)
            actualCellSize: 0,        // Calculated at runtime
            gridOffsetX: 0,           // Calculated at runtime
            gridOffsetY: 0,           // Calculated at runtime
            updateInterval: 1000,     // Time between generations in ms
            maxHistory: 9,            // Number of generations to check for stability
            randomThreshold: 0.8,    // Probability of a cell being dead initially (0.0 - 1.0)
            // Color cycling settings
            colorCycling: true,       // Enable color cycling animation
            colorTransitionGens: 8,  // Number of generations to transition between colors
            backgroundColors: ['#001122', '#220011', '#112200'], // Background color waypoints
            foregroundColors: ['#3344DD', '#DD3344', '#44DD33'], // Foreground color waypoints
            layers: [
                { drawStyle: DRAW_STYLES.TL_DIAG_LINES },
                { drawStyle: DRAW_STYLES.BL_DIAG_LINES },
                { drawStyle: DRAW_STYLES.CIRCLES },
                { drawStyle: DRAW_STYLES.H_LINES },
                { drawStyle: DRAW_STYLES.V_LINES }
            ]
        };

        // Color cycling state
        let generationCount = 0;
        let currentBgColor = CONFIG.backgroundColors[0];
        let currentFgColor = CONFIG.foregroundColors[0];

        // Parse hex color to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // Convert RGB to hex
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (Math.round(r) << 16) + (Math.round(g) << 8) + Math.round(b)).toString(16).slice(1);
        }

        // Interpolate between two colors
        function interpolateColor(color1, color2, t) {
            const c1 = hexToRgb(color1);
            const c2 = hexToRgb(color2);
            const r = c1.r + (c2.r - c1.r) * t;
            const g = c1.g + (c2.g - c1.g) * t;
            const b = c1.b + (c2.b - c1.b) * t;
            return rgbToHex(r, g, b);
        }

        // Update colors based on generation count
        function updateColors() {
            if (!CONFIG.colorCycling) {
                currentBgColor = CONFIG.backgroundColors[0];
                currentFgColor = CONFIG.foregroundColors[0];
                return;
            }

            const numWaypoints = CONFIG.backgroundColors.length;
            const totalGens = CONFIG.colorTransitionGens * numWaypoints;
            const cyclePosition = generationCount % totalGens;
            const waypointIndex = Math.floor(cyclePosition / CONFIG.colorTransitionGens);
            const nextWaypointIndex = (waypointIndex + 1) % numWaypoints;
            const t = (cyclePosition % CONFIG.colorTransitionGens) / CONFIG.colorTransitionGens;

            currentBgColor = interpolateColor(
                CONFIG.backgroundColors[waypointIndex],
                CONFIG.backgroundColors[nextWaypointIndex],
                t
            );
            currentFgColor = interpolateColor(
                CONFIG.foregroundColors[waypointIndex],
                CONFIG.foregroundColors[nextWaypointIndex],
                t
            );

            // Update all layers to use the same foreground color
            CONFIG.layers.forEach(layer => {
                layer.color = currentFgColor;
            });
        }

        // Initialize colors
        updateColors();

        let width, height;
        let cols, rows;

        // Resize canvas to fill window
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            const minDim = Math.min(width, height);
            // Calculate cell size based on percentage, round down to ensure fit
            let size = Math.floor(minDim * CONFIG.cellSizePercent);
            // Ensure at least 1 pixel
            size = Math.max(size, 1);
            CONFIG.actualCellSize = size;

            cols = Math.floor(width / size);
            rows = Math.floor(height / size);

            // Calculate offsets to center the grid (letterbox/pillarbox)
            CONFIG.gridOffsetX = Math.floor((width - cols * size) / 2);
            CONFIG.gridOffsetY = Math.floor((height - rows * size) / 2);

            // Re-initialize layers on resize to fit new dimensions
            // Note: This resets the game, which is acceptable for a simple demo
            initLayers();
        }

        window.addEventListener('resize', resize);

        class LifeLayer {
            constructor(config) {
                this.color = config.color;
                this.drawStyle = config.drawStyle || DRAW_STYLES.SOLID;
                this.grid = [];
                this.nextGrid = [];
                this.history = [];
                this.maxHistory = CONFIG.maxHistory;
            }

            init() {
                this.grid = new Array(cols).fill(null).map(() => new Array(rows).fill(0));
                this.nextGrid = new Array(cols).fill(null).map(() => new Array(rows).fill(0));
                this.history = [];

                // Randomize
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        this.grid[i][j] = Math.random() > CONFIG.randomThreshold ? 1 : 0;
                    }
                }

                // Compute initial next state so we can interpolate immediately
                this.computeNext();
            }

            computeNext() {
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        let state = this.grid[i][j];
                        let neighbors = this.countNeighbors(i, j);

                        if (state === 0 && neighbors === 3) {
                            this.nextGrid[i][j] = 1;
                        } else if (state === 1 && (neighbors < 2 || neighbors > 3)) {
                            this.nextGrid[i][j] = 0;
                        } else {
                            this.nextGrid[i][j] = state;
                        }
                    }
                }
            }

            step() {
                // Check for stability before advancing
                if (this.isStable()) {
                    // Instead of abruptly resetting, set nextGrid to a new random state
                    // This allows the transition system to smoothly fade to the new state
                    for (let i = 0; i < cols; i++) {
                        for (let j = 0; j < rows; j++) {
                            this.nextGrid[i][j] = Math.random() > CONFIG.randomThreshold ? 1 : 0;
                        }
                    }
                    // Clear history since we're starting fresh
                    this.history = [];
                    // Don't advance grid or compute next - just let the transition happen
                    return;
                }

                // Add current state to history
                this.addToHistory();

                // Advance: nextGrid becomes current grid
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        this.grid[i][j] = this.nextGrid[i][j];
                    }
                }

                // Compute new nextGrid
                this.computeNext();
            }

            addToHistory() {
                // Create a simple signature of the grid
                // Since grid is 0/1, we can just join it.
                // For performance with larger grids, a hash would be better, but for this size string is ok.
                const signature = this.grid.map(row => row.join('')).join('');
                this.history.push(signature);
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }
            }

            isStable() {
                if (this.history.length === 0) return false;
                const currentSignature = this.grid.map(row => row.join('')).join('');
                return this.history.includes(currentSignature);
            }

            countNeighbors(x, y) {
                let sum = 0;
                for (let i = -1; i < 2; i++) {
                    for (let j = -1; j < 2; j++) {
                        let col = (x + i + cols) % cols;
                        let row = (y + j + rows) % rows;
                        sum += this.grid[col][row];
                    }
                }
                sum -= this.grid[x][y];
                return sum;
            }

            draw(ctx, alpha) {
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2; // Line width for patterns

                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        let start = this.grid[i][j];
                        let end = this.nextGrid[i][j];

                        // Interpolate opacity
                        // If start=1, end=1: opacity 1
                        // If start=0, end=0: opacity 0
                        // If start=1, end=0: opacity 1 -> 0 (1 - alpha)
                        // If start=0, end=1: opacity 0 -> 1 (alpha)

                        let opacity = 0;
                        if (start === 1 && end === 1) opacity = 1;
                        else if (start === 1 && end === 0) opacity = 1 - alpha;
                        else if (start === 0 && end === 1) opacity = alpha;

                        if (opacity > 0.01) {
                            ctx.globalAlpha = opacity;
                            this.drawCell(ctx,
                                CONFIG.gridOffsetX + i * CONFIG.actualCellSize,
                                CONFIG.gridOffsetY + j * CONFIG.actualCellSize,
                                CONFIG.actualCellSize
                            );
                        }
                    }
                }
                ctx.globalAlpha = 1.0; // Reset
            }

            drawCell(ctx, x, y, size) {
                ctx.beginPath();
                switch (this.drawStyle) {
                    case DRAW_STYLES.TL_DIAG_LINES:
                        // Top-Left to Bottom-Right
                        // Calculate spacing to align with cell boundaries
                        // Target ~11px (8 * sqrt(2)) but adjust to divide evenly into size
                        const targetSpacing1 = 11;
                        const numLines1 = Math.round(size / targetSpacing1);
                        const diagSpacing1 = size / numLines1;

                        for (let k = 0; k <= size; k += diagSpacing1) {
                            // Lines parallel to main diagonal, offset by k
                            if (k === 0) {
                                // Center diagonal
                                ctx.moveTo(x, y);
                                ctx.lineTo(x + size, y + size);
                            } else {
                                // Upper-left side
                                if (k < size) {
                                    ctx.moveTo(x, y + k);
                                    ctx.lineTo(x + size - k, y + size);
                                }
                                // Lower-right side
                                if (k < size) {
                                    ctx.moveTo(x + k, y);
                                    ctx.lineTo(x + size, y + size - k);
                                }
                            }
                        }
                        ctx.stroke();
                        break;
                    case DRAW_STYLES.BL_DIAG_LINES:
                        // Bottom-Left to Top-Right
                        // Calculate spacing to align with cell boundaries
                        // Target ~11px (8 * sqrt(2)) but adjust to divide evenly into size
                        const targetSpacing2 = 11;
                        const numLines2 = Math.round(size / targetSpacing2);
                        const diagSpacing2 = size / numLines2;

                        for (let k = 0; k <= size; k += diagSpacing2) {
                            // Lines parallel to main diagonal, offset by k
                            if (k === 0) {
                                // Center diagonal
                                ctx.moveTo(x, y + size);
                                ctx.lineTo(x + size, y);
                            } else {
                                // Lower-left side
                                if (k < size) {
                                    ctx.moveTo(x, y + size - k);
                                    ctx.lineTo(x + size - k, y);
                                }
                                // Upper-right side
                                if (k < size) {
                                    ctx.moveTo(x + k, y + size);
                                    ctx.lineTo(x + size, y + k);
                                }
                            }
                        }
                        ctx.stroke();
                        break;
                    case DRAW_STYLES.H_LINES:
                        // Calculate spacing with reduced padding on top and bottom
                        const targetSpacingH = 8;
                        const numLinesH = Math.floor(size / targetSpacingH);
                        const paddingFactorH = 0.5; // Padding is 30% of normal gap
                        const totalPaddingH = 2 * paddingFactorH * targetSpacingH;
                        const spacingH = (size - totalPaddingH) / (numLinesH - 1);
                        const startOffsetH = paddingFactorH * targetSpacingH;

                        for (let i = 0; i < numLinesH; i++) {
                            const k = startOffsetH + (i * spacingH);
                            ctx.moveTo(x, y + k);
                            ctx.lineTo(x + size, y + k);
                        }
                        ctx.stroke();
                        break;
                    case DRAW_STYLES.V_LINES:
                        // Calculate spacing with reduced padding on left and right
                        const targetSpacingV = 8;
                        const numLinesV = Math.floor(size / targetSpacingV);
                        const paddingFactorV = 0.5; // Padding is 30% of normal gap
                        const totalPaddingV = 2 * paddingFactorV * targetSpacingV;
                        const spacingV = (size - totalPaddingV) / (numLinesV - 1);
                        const startOffsetV = paddingFactorV * targetSpacingV;

                        for (let i = 0; i < numLinesV; i++) {
                            const k = startOffsetV + (i * spacingV);
                            ctx.moveTo(x + k, y);
                            ctx.lineTo(x + k, y + size);
                        }
                        ctx.stroke();
                        break;
                    case DRAW_STYLES.SOLID_CIRCLE:
                        ctx.arc(x + size / 2, y + size / 2, size / 3, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case DRAW_STYLES.CIRCLES:
                        // Draw concentric circles from outer edge to center
                        // Match density to line patterns (lines use 8px spacing)
                        const spacing = 8;
                        const padding = 6; // More padding from cell edge
                        const maxRadius = size / 2 - padding;
                        const numCircles = Math.floor(maxRadius / spacing);
                        for (let k = 0; k <= numCircles; k++) {
                            ctx.beginPath();
                            const radius = maxRadius - (k * spacing);
                            if (radius > 0) {
                                ctx.arc(x + size / 2, y + size / 2, radius, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                        break;
                    case DRAW_STYLES.SOLID:
                    default:
                        ctx.rect(x, y, size, size);
                        ctx.fill();
                        break;
                }
            }
        }

        let layers = [];

        function initLayers() {
            layers = CONFIG.layers.map(layerConfig => new LifeLayer(layerConfig));
            layers.forEach(layer => layer.init());
        }

        let lastUpdate = 0;

        function loop(timestamp) {
            if (!lastUpdate) lastUpdate = timestamp;
            const elapsed = timestamp - lastUpdate;

            // Calculate interpolation factor (0.0 to 1.0)
            // Clamp to 1.0 to avoid overshooting if frame drops
            let alpha = Math.min(elapsed / CONFIG.updateInterval, 1.0);

            if (elapsed > CONFIG.updateInterval) {
                // Update all layers
                layers.forEach(layer => layer.step());
                generationCount++;
                updateColors();
                lastUpdate = timestamp;
                alpha = 0; // Reset alpha for new frame
            }

            // Clear screen
            ctx.fillStyle = currentBgColor;
            ctx.fillRect(0, 0, width, height);

            // Draw all layers with configured blending
            ctx.globalCompositeOperation = CONFIG.blendMode;
            layers.forEach(layer => layer.draw(ctx, alpha));
            ctx.globalCompositeOperation = 'source-over'; // Reset

            requestAnimationFrame(loop);
        }

        // Start
        resize();
        loop();

    </script>
</body>
</html>
